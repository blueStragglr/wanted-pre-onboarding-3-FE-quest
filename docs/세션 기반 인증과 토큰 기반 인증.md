# 세션 기반 인증과 토큰 기반 인증

## 인증/인가이란?

인증과 인가가 비슷하게 들릴 수도 있지만 IAM(Identity and Access Management) 환경에서는 명확히 구분되는 보안 프로세스입니다.

### 인증(Authentication)

인증이란 사용자의 신원을 검증하는 프로세스를 뜻합니다. 가장 간단한 예시로는 ID와 PW를 통해 로그인하는 행위가 있습니다.

### 인가(Authorization)

인가는 인증 이후의 프로세스입니다. 인가란 인증된 사용자가 어떠한 자원에 접근할 수 있는지를 확인하는 절차입니다.

## HTTP: 비연결성(Stateless)과 비상태성(Connectionless)

웹 사이트는 HTTP 통신 위에서 동작합니다. 이로 인해 웹 사이트에서 발생하는 대부분의 요청과 응답은 비연결성과 비상태성이라는 특성을 가집니다.

- HTTP의 비연결성(Connectionless): 요청과 응답을 한번 주고받으면 바로 연결을 끊어버리고 다음 요청을 하기 위해 다시 연결을 해야하는 특성
- HTTP의 비상태성(Stateless) : 요청과 응답을 교환하는 동안 상태(Status)를 저장하지 않는 특성, HTTP 레벨에서는 이전에 보냈던 리퀘스트나 리스폰스를 기억하지 못하는 특성

이러한 특성을 인증과 함께 생각해보면 로그인을 통해 인증을 거쳐도 이후 요청에서는 이전의 인증된 상태를 유지하지 않게 됩니다. 이러한 상황에서 웹 사이트를 이용하려면 인증/인가가 필요한 모든 상황에서 사용자는 반복적으로 ID/PW를 입력해야 하는 좋지 못한 유저 경험을 초래할 수 있다.

## 쿠키(Cookie)

HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 데이터 조각입니다. 브라우저는 서버에서 받은 데이터(Cookie)를 저장해 놓았다가 동일한 서버로 재요청 시 제공받았던 데이터를 함께 전송하죠. 이를 통해 HTTP의 stateless를 보완해 HTTP 통신에서도 상태 정보를 보존 할 수 있습니다.

단점

- 성능이슈: 브라우저마다 다르겠지만 일반적으로 쿠키의 데이터는 4kb로 제한이 되어있다. 만약 쿠키에 저장된 정보가 많다면, 매번 요청마다 큰 오버헤드가 발생할 수 있다.
- 보인이슈: 브라우저에 저장하기 때문에 유실/변조/도난되기 쉽습니다. 이를 방지하기 위해 secure, httpOnly, sameSite와 같은 설정을 할 수 있습니다.

## 세션(Session)

세션이란 사용자가 로그인 이후 로그아웃 혹은 로그인 만료까지의 기간이라고 할 수 있습니다. 쿠키와 달리 사용자 정보를 서버측에 저장합니다. 세션은 고객의 주요 정보가 아닌, 단지 고객을 식별할 수 있는 값 생성해 쿠키로 주고받습니다. 예를 들어 A 사용자가 ID/PW를 통해 로그인을 했다면 A사용자를 식별할 수 있는 값를 생성해 쿠키로 브라우저에 심고 매번 요청 때마다 생성한 값을 통해 인증/인가를 진행할 수 있습니다.

장점

- 서버가 클라이언트의 웹 브라우저에 의존하지 않아도 된다.
- 쿠키를 포함한 요청이 외부에 노출되어도 세션 ID 자체는 유의미한 개인 정보를 담지 않는다.

단점

- 서버에서 세션 저장소를 사용하기 때문에, 요청이 많아지면 서버에 부하가 생긴다.

## JWT(JSON Web Token)

JWT(JSON Web Token)는 인증에 필요한 정보들을 암호화시킨 토큰이다. JWT 기반 인증은 쿠키/세션 방식과 유사하게 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별한다.

### 토큰 기반 인증

장점

- 이미 토큰 자체가 인증된 정보이기 때문에 세션 저장소와 같은 별도의 인증 저장소가 "필수적"으로 필요하지 않는다.
- 세션과는 다르게 클라이언트의 상태를 서버가 저장해 두지 않아도 된다.
- signature를 공통 키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보완성이 늘어납니다.
- 다른 서비스에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있습니다.

단점

- 쿠키, 세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많을수록 네트워크 부하가 심해진다.
- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. (패스워드 등)
- 토큰을 탈취당하면 대처하기 어렵다. 토큰은 한 번 발급되면 유효기간이 만료될 때까지 계속 사용이 가능하다.
- 특정 사용자의 접속을 강제로 만료하기 어렵다. (쿠키/세션 기반 인증은 서버 단에서 쉽게 삭제할 수 있지만 토큰은 안 된다)

## JWT 단점을 보완하는 방법

`토큰이  탈취당하면 만료될 때까지 대처가 불가능하다.`하다는 단점은 심각한 문제를 초래할 수 있습니다. 세션 기반의 인가 방식에서 세션을 탈취당한다고 판단이 되었을 때 세션 저장소를 끊어서 탈취당한 세션 ID가 있더라도 세션 저장소에 그 값을 지워 탈취된 후의 상황을 보완할 수 있습니다. 하지만 토큰을 활용한 방식은 서버에서 클라이언트의 상태를 저장하는 stateful한 상황이 아닌 stateless한 상황입니다.

서버에서 JWT를 발급하고 클라이언트에서 관리하는 형태이기 때문에 JWT가 탈취되었더라도 서버가 판단할 수 없습니다.

### 만료시간을 짧게 설정

토큰의 만료 기한을 짧게 설정해서 탈취되더라도 빠르게 만료시키는 방법이다.
하지만 이는 토큰이 만료되면 사용자가 다시 로그인해야 한다는 뜻이기에 사용자 입장에서 번거로운 방법이다. 이를 보완할 수 있는 방법으로 Sliding Session과 Refresh Token을 활용할 수 있습니다.

#### Sliding Session

특정한 서비스를 계속 사용하고 있는 특정 유저에 대해 만료 시간을 연장시켜주는 방법입니다.

유저가 글을 작성할 수 있는 서비스를 예시로 들어보자면, 글을 쓰다가 인증 시간이 만료되어 글이 날아가면 불편할 수 있습니다. 이 때, Sliding Session을 사용하여 글쓰기, 결제 등과 같은 특정 action을 유저가 행동하였을 때 새롭게 만료시간을 늘린 JWT를 다시 제공함으로써 만료시간을 연장하여 짧은 만료시간을 보완할 수 있습니다.

하지만 접속이 단발성으로 일어난다면 Sliding Session으로 연장시켜줄 수 없는 상황이 생기고, 너무 긴 Access Token을 발급시켜준 상황이라면 Sliding Session 때문에 무한정 사용하는 상황이 발생할 수 있습니다.

#### Refresh Token

JWT를 처음 발급할 때 Access Token과 함께 Refresh Token이라는 토큰을 발급하여 짧은 만료시간을 해결하는 방법입니다.

Access Token은 비교적 짧은 만료시간을 설정하고, Refresh Token은 비교적 긴 시간(7일, 30일 등)의 만료시간을 설정합니다. Refresh Token은 Access Token을 재발급(Refresh)해주는 기능을 합니다. 클라이언트가 Access Token이 만료됨을 본인이 인지하거나, 서버로부터 만료됨을 확인받았다면 Refresh Token으로 서버에게 새로운 Access Token을 발급하도록 요청하여 발급받는 방식입니다. (Refresh Token이 공격자에게 탈취될 경우, 해당 공격자가, 토큰을 계속 refresh하여 사실상 기한제한 없이 로그인을 유지할 수 있다는 단점을 막을 수 있습니다.)

이때 서버는 DB에 저장된 Refresh Token과 비교하여 유효하면 Access Token을 발급합니다. (서버에서 세션 스토리지와 비슷한 Refresh Token Storage를 두어 관리합니다.) 만약 Refresh Token도 만료된 경우라면 사용자에게 로그인을 요구하면 됩니다.

> 하지만 세션의 I/O 작업에 대한 단점을 다 가져가니까 어차피 세션이랑 똑같은 거 아니야?라는 생각을 가지면 안 됩니다.
>
> 세션은 항상 인증 요청을 할 때마다 세션 ID를 세션 저장소에 있는 세션 ID에 비교를 해야 해요. 예를 들어 30분에 1만 번의 요청을 한다고 했을 때 I/O는 1만 번 작동하겠죠.
>
> 근데 Refresh Token은 Refresh 하는 그 순간 즉, 요청을 했는데 access token이 만료되었을 때만 I/O 작업을 해요. 30분에 1만 번의 요청을 한다고 했을 때 1만 번 access token으로 I/O 작업 없이 요청을 주고받고 30분이 지나면 딱 한번 Refresh 하기 위해서 요청을 하는 셈이죠.
> 출처: https://brunch.co.kr/@jinyoungchoi95/1

## 참고자료

- 3월 원티드 프리온보딩 프론트엔드 과정 사전과제: https://www.wanted.co.kr/events/pre_challenge_fe_7
- https://www.okta.com/kr/identity-101/authentication-vs-authorization/
- https://dev.gmarket.com/45
- https://hudi.blog/session-based-auth-vs-token-based-auth/
- https://hudi.blog/cookie-and-session
- https://velog.io/@whitebear/쿠키-세션-토큰JWT-확실히-알고-가기
- https://brunch.co.kr/@jinyoungchoi95/1
