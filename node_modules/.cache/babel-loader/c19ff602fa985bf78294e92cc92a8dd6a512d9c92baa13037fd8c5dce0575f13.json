{"ast":null,"code":"var IMPORTANT_MODIFIER = '!';\nfunction createSplitModifiers(config) {\n  var separator = config.separator || ':';\n  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n  return function splitModifiers(className) {\n    var bracketDepth = 0;\n    var modifiers = [];\n    var modifierStart = 0;\n    for (var index = 0; index < className.length; index++) {\n      var _char = className[index];\n      if (bracketDepth === 0 && _char === separator[0]) {\n        if (separator.length === 1 || className.slice(index, index + separator.length) === separator) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separator.length;\n        }\n      }\n      if (_char === '[') {\n        bracketDepth++;\n      } else if (_char === ']') {\n        bracketDepth--;\n      }\n    }\n    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    return {\n      modifiers: modifiers,\n      hasImportantModifier: hasImportantModifier,\n      baseClassName: baseClassName\n    };\n  };\n}\n/**\r\n * Sorts modifiers according to following schema:\r\n * - Predefined modifiers are sorted alphabetically\r\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\r\n */\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  var sortedModifiers = [];\n  var unsortedModifiers = [];\n  modifiers.forEach(function (modifier) {\n    var isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());\n  return sortedModifiers;\n}\nexport { IMPORTANT_MODIFIER, createSplitModifiers, sortModifiers };","map":{"version":3,"mappings":"AAEO,IAAMA,kBAAkB,GAAG;AAE5B,SAAUC,oBAAoB,CAACC,MAAc;EAC/C,IAAMC,SAAS,GAAGD,MAAM,CAACC,SAAS,IAAI,GAAG;EAEzC;EACA,OAAO,SAASC,cAAc,CAACC,SAAiB;IAC5C,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIC,aAAa,GAAG,CAAC;IAErB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,SAAS,CAACK,MAAM,EAAED,KAAK,EAAE,EAAE;MACnD,IAAIE,KAAI,GAAGN,SAAS,CAACI,KAAK,CAAC;MAE3B,IAAIH,YAAY,KAAK,CAAC,IAAIK,KAAI,KAAKR,SAAS,CAAC,CAAC,CAAC,EAAE;QAC7C,IACIA,SAAS,CAACO,MAAM,KAAK,CAAC,IACtBL,SAAS,CAACO,KAAK,CAACH,KAAK,EAAEA,KAAK,GAAGN,SAAS,CAACO,MAAM,CAAC,KAAKP,SAAS,EAChE;UACEI,SAAS,CAACM,IAAI,CAACR,SAAS,CAACO,KAAK,CAACJ,aAAa,EAAEC,KAAK,CAAC,CAAC;UACrDD,aAAa,GAAGC,KAAK,GAAGN,SAAS,CAACO,MAAM;QAC3C;MACJ;MAED,IAAIC,KAAI,KAAK,GAAG,EAAE;QACdL,YAAY,EAAE;MACjB,OAAM,IAAIK,KAAI,KAAK,GAAG,EAAE;QACrBL,YAAY,EAAE;MACjB;IACJ;IAED,IAAMQ,kCAAkC,GACpCP,SAAS,CAACG,MAAM,KAAK,CAAC,GAAGL,SAAS,GAAGA,SAAS,CAACU,SAAS,CAACP,aAAa,CAAC;IAC3E,IAAMQ,oBAAoB,GACtBF,kCAAkC,CAACG,UAAU,CAACjB,kBAAkB,CAAC;IACrE,IAAMkB,aAAa,GAAGF,oBAAoB,GACpCF,kCAAkC,CAACC,SAAS,CAAC,CAAC,CAAC,GAC/CD,kCAAkC;IAExC,OAAO;MACHP,SAAS,EAATA,SAAS;MACTS,oBAAoB,EAApBA,oBAAoB;MACpBE,aAAa,EAAbA;KACH;GACJ;AACL;AAEA;;;;AAIG;AACG,SAAUC,aAAa,CAACZ,SAAmB;EAC7C,IAAIA,SAAS,CAACG,MAAM,IAAI,CAAC,EAAE;IACvB,OAAOH,SAAS;EACnB;EAED,IAAMa,eAAe,GAAa,EAAE;EACpC,IAAIC,iBAAiB,GAAa,EAAE;EAEpCd,SAAS,CAACe,OAAO,CAAC,UAACC,QAAQ,EAAI;IAC3B,IAAMC,kBAAkB,GAAGD,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG;IAE9C,IAAIC,kBAAkB,EAAE;MACpBJ,eAAe,CAACP,IAAI,OAApBO,eAAe,EAASC,iBAAiB,CAACI,IAAI,EAAE,CAAEF,gBAAQ,CAAC;MAC3DF,iBAAiB,GAAG,EAAE;IACzB,OAAM;MACHA,iBAAiB,CAACR,IAAI,CAACU,QAAQ,CAAC;IACnC;EACL,CAAC,CAAC;EAEFH,eAAe,CAACP,IAAI,CAApBO,qBAAe,EAASC,iBAAiB,CAACI,IAAI,EAAE,CAAC;EAEjD,OAAOL,eAAe;AAC1B","names":["IMPORTANT_MODIFIER","createSplitModifiers","config","separator","splitModifiers","className","bracketDepth","modifiers","modifierStart","index","length","char","slice","push","baseClassNameWithImportantModifier","substring","hasImportantModifier","startsWith","baseClassName","sortModifiers","sortedModifiers","unsortedModifiers","forEach","modifier","isArbitraryVariant","sort"],"sources":["/Users/johyeyeon/wanted-pre-onboarding-3-FE-quest/node_modules/tailwind-merge/src/lib/modifier-utils.ts"],"sourcesContent":["import { Config } from './types'\n\nexport const IMPORTANT_MODIFIER = '!'\n\nexport function createSplitModifiers(config: Config) {\n    const separator = config.separator || ':'\n\n    // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n    return function splitModifiers(className: string) {\n        let bracketDepth = 0\n        let modifiers = []\n        let modifierStart = 0\n\n        for (let index = 0; index < className.length; index++) {\n            let char = className[index]\n\n            if (bracketDepth === 0 && char === separator[0]) {\n                if (\n                    separator.length === 1 ||\n                    className.slice(index, index + separator.length) === separator\n                ) {\n                    modifiers.push(className.slice(modifierStart, index))\n                    modifierStart = index + separator.length\n                }\n            }\n\n            if (char === '[') {\n                bracketDepth++\n            } else if (char === ']') {\n                bracketDepth--\n            }\n        }\n\n        const baseClassNameWithImportantModifier =\n            modifiers.length === 0 ? className : className.substring(modifierStart)\n        const hasImportantModifier =\n            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)\n        const baseClassName = hasImportantModifier\n            ? baseClassNameWithImportantModifier.substring(1)\n            : baseClassNameWithImportantModifier\n\n        return {\n            modifiers,\n            hasImportantModifier,\n            baseClassName,\n        }\n    }\n}\n\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nexport function sortModifiers(modifiers: string[]) {\n    if (modifiers.length <= 1) {\n        return modifiers\n    }\n\n    const sortedModifiers: string[] = []\n    let unsortedModifiers: string[] = []\n\n    modifiers.forEach((modifier) => {\n        const isArbitraryVariant = modifier[0] === '['\n\n        if (isArbitraryVariant) {\n            sortedModifiers.push(...unsortedModifiers.sort(), modifier)\n            unsortedModifiers = []\n        } else {\n            unsortedModifiers.push(modifier)\n        }\n    })\n\n    sortedModifiers.push(...unsortedModifiers.sort())\n\n    return sortedModifiers\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}