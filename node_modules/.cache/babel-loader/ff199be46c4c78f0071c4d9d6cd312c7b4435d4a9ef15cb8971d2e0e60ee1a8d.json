{"ast":null,"code":"import * as cookie from 'cookie';\nexport function hasDocumentCookie() {\n  // Can we get/set cookies on document.cookie?\n  return typeof document === 'object' && typeof document.cookie === 'string';\n}\nexport function cleanCookies() {\n  document.cookie.split(';').forEach(function (c) {\n    document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\n  });\n}\nexport function parseCookies(cookies, options) {\n  if (typeof cookies === 'string') {\n    return cookie.parse(cookies, options);\n  } else if (typeof cookies === 'object' && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nexport function isParsingCookie(value, doNotParse) {\n  if (typeof doNotParse === 'undefined') {\n    // We guess if the cookie start with { or [, it has been serialized\n    doNotParse = !value || value[0] !== '{' && value[0] !== '[' && value[0] !== '\"';\n  }\n  return !doNotParse;\n}\nexport function readCookie(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var cleanValue = cleanupCookieValue(value);\n  if (isParsingCookie(cleanValue, options.doNotParse)) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {\n      // At least we tried\n    }\n  }\n  // Ignore clean value if we failed the deserialization\n  // It is not relevant anymore to trim those values\n  return value;\n}\nfunction cleanupCookieValue(value) {\n  // express prepend j: before serializing a cookie\n  if (value && value[0] === 'j' && value[1] === ':') {\n    return value.substr(2);\n  }\n  return value;\n}","map":{"version":3,"names":["cookie","hasDocumentCookie","document","cleanCookies","split","forEach","c","replace","Date","toUTCString","parseCookies","cookies","options","parse","isParsingCookie","value","doNotParse","readCookie","cleanValue","cleanupCookieValue","JSON","e","substr"],"sources":["/Users/johyeyeon/so-hyeppy/node_modules/universal-cookie/es6/utils.js"],"sourcesContent":["import * as cookie from 'cookie';\r\nexport function hasDocumentCookie() {\r\n    // Can we get/set cookies on document.cookie?\r\n    return typeof document === 'object' && typeof document.cookie === 'string';\r\n}\r\nexport function cleanCookies() {\r\n    document.cookie.split(';').forEach(function (c) {\r\n        document.cookie = c\r\n            .replace(/^ +/, '')\r\n            .replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\r\n    });\r\n}\r\nexport function parseCookies(cookies, options) {\r\n    if (typeof cookies === 'string') {\r\n        return cookie.parse(cookies, options);\r\n    }\r\n    else if (typeof cookies === 'object' && cookies !== null) {\r\n        return cookies;\r\n    }\r\n    else {\r\n        return {};\r\n    }\r\n}\r\nexport function isParsingCookie(value, doNotParse) {\r\n    if (typeof doNotParse === 'undefined') {\r\n        // We guess if the cookie start with { or [, it has been serialized\r\n        doNotParse =\r\n            !value || (value[0] !== '{' && value[0] !== '[' && value[0] !== '\"');\r\n    }\r\n    return !doNotParse;\r\n}\r\nexport function readCookie(value, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var cleanValue = cleanupCookieValue(value);\r\n    if (isParsingCookie(cleanValue, options.doNotParse)) {\r\n        try {\r\n            return JSON.parse(cleanValue);\r\n        }\r\n        catch (e) {\r\n            // At least we tried\r\n        }\r\n    }\r\n    // Ignore clean value if we failed the deserialization\r\n    // It is not relevant anymore to trim those values\r\n    return value;\r\n}\r\nfunction cleanupCookieValue(value) {\r\n    // express prepend j: before serializing a cookie\r\n    if (value && value[0] === 'j' && value[1] === ':') {\r\n        return value.substr(2);\r\n    }\r\n    return value;\r\n}\r\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,QAAQ;AAChC,OAAO,SAASC,iBAAiB,GAAG;EAChC;EACA,OAAO,OAAOC,QAAQ,KAAK,QAAQ,IAAI,OAAOA,QAAQ,CAACF,MAAM,KAAK,QAAQ;AAC9E;AACA,OAAO,SAASG,YAAY,GAAG;EAC3BD,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,CAAC,UAAUC,CAAC,EAAE;IAC5CJ,QAAQ,CAACF,MAAM,GAAGM,CAAC,CACdC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClBA,OAAO,CAAC,KAAK,EAAE,YAAY,GAAG,IAAIC,IAAI,EAAE,CAACC,WAAW,EAAE,GAAG,SAAS,CAAC;EAC5E,CAAC,CAAC;AACN;AACA,OAAO,SAASC,YAAY,CAACC,OAAO,EAAEC,OAAO,EAAE;EAC3C,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;IAC7B,OAAOX,MAAM,CAACa,KAAK,CAACF,OAAO,EAAEC,OAAO,CAAC;EACzC,CAAC,MACI,IAAI,OAAOD,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;IACtD,OAAOA,OAAO;EAClB,CAAC,MACI;IACD,OAAO,CAAC,CAAC;EACb;AACJ;AACA,OAAO,SAASG,eAAe,CAACC,KAAK,EAAEC,UAAU,EAAE;EAC/C,IAAI,OAAOA,UAAU,KAAK,WAAW,EAAE;IACnC;IACAA,UAAU,GACN,CAACD,KAAK,IAAKA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAI;EAC5E;EACA,OAAO,CAACC,UAAU;AACtB;AACA,OAAO,SAASC,UAAU,CAACF,KAAK,EAAEH,OAAO,EAAE;EACvC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIM,UAAU,GAAGC,kBAAkB,CAACJ,KAAK,CAAC;EAC1C,IAAID,eAAe,CAACI,UAAU,EAAEN,OAAO,CAACI,UAAU,CAAC,EAAE;IACjD,IAAI;MACA,OAAOI,IAAI,CAACP,KAAK,CAACK,UAAU,CAAC;IACjC,CAAC,CACD,OAAOG,CAAC,EAAE;MACN;IAAA;EAER;EACA;EACA;EACA,OAAON,KAAK;AAChB;AACA,SAASI,kBAAkB,CAACJ,KAAK,EAAE;EAC/B;EACA,IAAIA,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/C,OAAOA,KAAK,CAACO,MAAM,CAAC,CAAC,CAAC;EAC1B;EACA,OAAOP,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}